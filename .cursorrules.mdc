# 프론트엔드 개발 규칙

## 기술 스택
- React 19 + TypeScript + Vite
- framer-motion (애니메이션 필수)
- axios (API 호출)
- recharts (차트 시각화)

## 컴포넌트 구조 규칙

### 파일 구조
- 컴포넌트: `components/` 디렉토리 (PascalCase 파일명, 예: `SubscriptionList.tsx`)
- 페이지: `pages/` 디렉토리
- API 호출 함수: `services/api.ts`에서만 정의
- 커스텀 훅: `hooks/` 디렉토리
- 타입 정의: `types/index.ts`

### 컴포넌트 작성 규칙
- 함수형 컴포넌트만 사용 (클래스 컴포넌트 금지)
- TypeScript 타입 정의 필수 (`any` 타입 사용 금지)
- Props 인터페이스 명시적으로 정의
- 컴포넌트명과 파일명 일치

// ✅ 올바른 예시
interface SubscriptionListProps {
  userId: number;
  onSubscriptionUpdate?: () => void;
}

export const SubscriptionList: React.FC<SubscriptionListProps> = ({ userId, onSubscriptionUpdate }) => {
  // ...
};

// ❌ 잘못된 예시
export default function SubscriptionList(props: any) { // any 타입 금지
  // ...
}## API 호출 규칙

### 필수 규칙
- **모든 API 호출은 `services/api.ts`에서만 수행**
- 컴포넌트에서 직접 `axios` 호출 금지
- 에러 처리는 try-catch 사용
- 호출 경로 주석 필수
t
// ✅ 올바른 예시: services/api.ts
/**
 * 호출 경로: SubscriptionForm.handleSubmit()
 *          → api.createSubscription()
 *          → POST /api/subscriptions
 *          → SubscriptionController.create()
 */
export const createSubscription = async (
  data: SubscriptionRequestDto
): Promise<SubscriptionResponseDto> => {
  try {
    const response = await axios.post('/api/subscriptions', data);
    return response.data;
  } catch (error) {
    console.error('구독 서비스 생성 실패', error);
    throw error;
  }
};

// ❌ 잘못된 예시: 컴포넌트에서 직접 호출
const Component = () => {
  useEffect(() => {
    axios.get('/api/subscriptions').then(...); // 금지!
  }, []);
};## 애니메이션 규칙 (React Bits 스타일)

### 필수 애니메이션
- 모든 인터랙티브 요소: hover, click 애니메이션 포함
- 리스트 아이템: 등장 애니메이션 (stagger 효과)
- 폼 제출: 로딩 스피너, 성공/실패 피드백 애니메이션
- 카드/모달: 슬라이드/페이드 애니메이션

### framer-motion 사용 규칙
import { motion } from 'framer-motion';

/**
 * 호출 경로: App.tsx
 *          → SubscriptionList (렌더링)
 *          → api.getSubscriptions() (데이터 로드)
 * 
 * 애니메이션: 리스트 아이템 등장 시 stagger 효과, hover 시 scale 효과
 */
export const SubscriptionList: React.FC = () => {
  const [subscriptions, setSubscriptions] = useState<SubscriptionResponseDto[]>([]);
  
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
    >
      {subscriptions.map((sub, index) => (
        <motion.div
          key={sub.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.1 }}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
        >
          {/* 내용 */}
        </motion.div>
      ))}
    </motion.div>
  );
};### 애니메이션 가이드라인
- **리스트 아이템**: `transition={{ delay: index * 0.1 }}` (stagger 효과)
- **버튼/카드 hover**: `whileHover={{ scale: 1.02 }}`
- **버튼 클릭**: `whileTap={{ scale: 0.98 }}`
- **등장 애니메이션**: `initial={{ opacity: 0, y: 20 }}`, `animate={{ opacity: 1, y: 0 }}`
- **슬라이드 인**: `initial={{ x: -100, opacity: 0 }}`, `animate={{ x: 0, opacity: 1 }}`

## 상태 관리 규칙

### 로컬 상태
- `useState` 사용 (간단한 상태)
- `useReducer` 사용 (복잡한 상태 로직)

### 서버 상태
- `useEffect` + `useState` 조합 사용
- 또는 React Query 사용 (선택사항)

// ✅ 올바른 예시
const [subscriptions, setSubscriptions] = useState<SubscriptionResponseDto[]>([]);
const [loading, setLoading] = useState(false);

useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const data = await api.getSubscriptions(userId);
      setSubscriptions(data);
    } catch (error) {
      console.error('구독 목록 조회 실패', error);
    } finally {
      setLoading(false);
    }
  };
  fetchData();
}, [userId]);## TypeScript 타입 규칙

### 필수 규칙
- 모든 함수, 변수에 타입 정의
- `any` 타입 사용 금지
- Props 인터페이스 명시
- API 응답 타입은 `types/index.ts`에서 정의

// ✅ 올바른 예시
interface FormData {
  serviceName: string;
  price: number;
  billingCycle: BillingCycle;
  billingDate: string;
}

const handleSubmit = async (data: FormData): Promise<void> => {
  // ...
};

// ❌ 잘못된 예시
const handleSubmit = async (data: any) => { // any 타입 금지
  // ...
};## 주석 규칙

### 호출 경로 주석 (필수)
복잡한 로직이나 다중 계층 호출 시 반드시 호출 경로 주석 추가:
ipt
/**
 * 호출 경로: SubscriptionForm.handleSubmit()
 *          → api.createSubscription()
 *          → POST /api/subscriptions
 *          → SubscriptionList.refresh() (상태 업데이트)
 * 
 * 애니메이션: 제출 시 로딩 스피너 표시, 성공 시 슬라이드 인 애니메이션
 */
const handleSubmit = async (data: SubscriptionFormData) => {
  // ...
};### 수학적 구조 주석
금액 계산, 날짜 계산 등 수학적 로직 설명:
cript
/**
 * 월별 지출액 계산 로직:
 * - MONTHLY: price (그대로)
 * - QUARTERLY: price ÷ 3
 * - YEARLY: price ÷ 12
 */
const calculateMonthlyExpense = (subscriptions: SubscriptionResponseDto[]): number => {
  // ...
};## 폼 처리 규칙

### 폼 제출 애니메이션
- 제출 시: 로딩 스피너 표시
- 성공 시: 슬라이드 인/페이드 애니메이션
- 실패 시: 에러 메시지 애니메이션
ipt
const [isSubmitting, setIsSubmitting] = useState(false);
const [submitStatus, setSubmitStatus] = useState<'idle' | 'success' | 'error'>('idle');

const handleSubmit = async (data: SubscriptionFormData) => {
  setIsSubmitting(true);
  try {
    await api.createSubscription(data);
    setSubmitStatus('success');
    // 성공 애니메이션
  } catch (error) {
    setSubmitStatus('error');
    // 에러 애니메이션
  } finally {
    setIsSubmitting(false);
  }
};## 스타일링 규칙

### CSS 규칙
- 컴포넌트별 CSS 모듈 또는 CSS-in-JS 사용
- 전역 스타일: `index.css`
- 컴포넌트 스타일: `ComponentName.css` 또는 CSS 모듈

### 클래스명 규칙
- kebab-case 사용 (예: `subscription-list`)
- BEM 방식 권장 (선택사항)

## 차트 구현 규칙

### recharts 사용
- `MonthlyExpenseChart` 컴포넌트에서 recharts 사용
- framer-motion으로 등장 애니메이션 추가
ipt
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import { motion } from 'framer-motion';

export const MonthlyExpenseChart: React.FC = () => {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <LineChart data={chartData}>
        {/* 차트 구성 */}
      </LineChart>
    </motion.div>
  );
};## 금지 사항

### 절대 하지 말아야 할 것
- ❌ 컴포넌트에서 직접 `axios` 호출 (services/api.ts 사용 필수)
- ❌ 애니메이션 없는 인터랙티브 요소 (React Bits 스타일 필수)
- ❌ `any` 타입 사용 (TypeScript 타입 정의 필수)
- ❌ 복잡한 로직에 주석 없이 구현 (호출 경로 주석 필수)
- ❌ 클래스 컴포넌트 사용 (함수형 컴포넌트만 사용)
- ❌ 설명적 주석 (명령형 주석만: "호출 경로:", "수학적 구조:")

## Vite 특화 규칙

### 환경 변수
- `.env` 파일에 환경 변수 정의
- `import.meta.env.VITE_*` 형식으로 접근

### 빌드 최적화
- 프로덕션 빌드: `npm run build`
- 개발 서버: `npm run dev`
- 코드 스플리팅 권장 (필요한 경우)
// ✅ 올바른 예시: services/api.ts
/**
 * 호출 경로: SubscriptionForm.handleSubmit()
 *          → api.createSubscription()
 *          → POST /api/subscriptions
 *          → SubscriptionController.create()
 */
export const createSubscription = async (
  data: SubscriptionRequestDto
): Promise<SubscriptionResponseDto> => {
  try {
    const response = await axios.post('/api/subscriptions', data);
    return response.data;
  } catch (error) {
    console.error('구독 서비스 생성 실패', error);
    throw error;
  }
};

// ❌ 잘못된 예시: 컴포넌트에서 직접 호출
const Component = () => {
  useEffect(() => {
    axios.get('/api/subscriptions').then(...); // 금지!
  }, []);
};
import { motion } from 'framer-motion';

/**
 * 호출 경로: App.tsx
 *          → SubscriptionList (렌더링)
 *          → api.getSubscriptions() (데이터 로드)
 * 
 * 애니메이션: 리스트 아이템 등장 시 stagger 효과, hover 시 scale 효과
 */
export const SubscriptionList: React.FC = () => {
  const [subscriptions, setSubscriptions] = useState<SubscriptionResponseDto[]>([]);
  
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
    >
      {subscriptions.map((sub, index) => (
        <motion.div
          key={sub.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.1 }}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
        >
          {/* 내용 */}
        </motion.div>
      ))}
    </motion.div>
  );
};
// ✅ 올바른 예시
const [subscriptions, setSubscriptions] = useState<SubscriptionResponseDto[]>([]);
const [loading, setLoading] = useState(false);

useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const data = await api.getSubscriptions(userId);
      setSubscriptions(data);
    } catch (error) {
      console.error('구독 목록 조회 실패', error);
    } finally {
      setLoading(false);
    }
  };
  fetchData();
}, [userId]);
// ✅ 올바른 예시
interface FormData {
  serviceName: string;
  price: number;
  billingCycle: BillingCycle;
  billingDate: string;
}

const handleSubmit = async (data: FormData): Promise<void> => {
  // ...
};

// ❌ 잘못된 예시
const handleSubmit = async (data: any) => { // any 타입 금지
  // ...
};
/**
 * 호출 경로: SubscriptionForm.handleSubmit()
 *          → api.createSubscription()
 *          → POST /api/subscriptions
 *          → SubscriptionList.refresh() (상태 업데이트)
 * 
 * 애니메이션: 제출 시 로딩 스피너 표시, 성공 시 슬라이드 인 애니메이션
 */
const handleSubmit = async (data: SubscriptionFormData) => {
  // ...
};
const [isSubmitting, setIsSubmitting] = useState(false);
const [submitStatus, setSubmitStatus] = useState<'idle' | 'success' | 'error'>('idle');

const handleSubmit = async (data: SubscriptionFormData) => {
  setIsSubmitting(true);
  try {
    await api.createSubscription(data);
    setSubmitStatus('success');
    // 성공 애니메이션
  } catch (error) {
    setSubmitStatus('error');
    // 에러 애니메이션
  } finally {
    setIsSubmitting(false);
  }
};
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import { motion } from 'framer-motion';

export const MonthlyExpenseChart: React.FC = () => {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <LineChart data={chartData}>
        {/* 차트 구성 */}
      </LineChart>
    </motion.div>
  );
};
